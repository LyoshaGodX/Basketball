import numpy as np

from generate_synthetic_data import generate_data

# -----------------------Первый этап-----------------------------

# Средние значения признаков
means_first_step = np.array([
    3.92, 37.20, 1.21, 52.20, 31.10, 174.70, 32.30, 12.40, 11.25, 4.25,
    20.25, 6.85, 15.25, 2.42, 4.57, 40.80, 4.33, 1.46, 13.70, 33.10,
    15.70, 47.20, 32.20, 3120.00
])

# Погрешности признаков (из вашей таблицы)
errors_first_step = np.array([
    0.05, 0.65, 0.08, 0.85, 0.54, 7.29, 0.78, 0.64, 0.73, 0.12,
    0.75, 0.54, 0.62, 0.04, 0.03, 0.69, 0.56, 0.07, 0.91, 1.52,
    0.42, 2.62, 1.82, 152.34
])


# TODO: Исправить генерацию синтетики
'''
Значения целочисленных критериев часто - это ряд одинаковых чисел. 
Придумать, как внести больше случайности программно. Либо не забывать после каждого этапа изменять
числа вручную.
'''
generate_data(means_first_step, errors_first_step, 'data_first_step.csv')

# TODO: Добавить в файл generate_synthetic_data.py функцию check_randomness для сверки с "реальными" данными
# TODO: Добавить в файл generate_synthetic_data.py функцию concatenate_data для объединения данных из разных этапов
# TODO: Переписать файл PCA.py в функциональном стиле
# TODO: Добавить в файл PCA.py функцию save_model для сохранения модели PCA. Модель сделать на основе всех трех этапов
# TODO: Добавить в файл PCA.py функцию load_model для загрузки модели PCA и применения её к каждому этапу. Это сделает выделенные факторы одинаковыми для всех этапов и позволит сравнивать их между этапами
# TODO: Создать файл metrix.py. В нем определить функции pairwise_correlation для сравнения факторов между этапами и перетащить plot_correlation из PCA.py для визуализации корреляционной матрицы. Создать другие функции для графиков и метрик
# TODO: Придумать визуализацию для вклада каждого признака в факторы. Например, гистограмму с накоплением. Добавить её в файл metrix.py
# TODO: Придумать другие TODO ^_^